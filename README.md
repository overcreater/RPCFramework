# RPCFramework 基于 Netty + Java 的轻量级分布式 RPC 框架

## 🤔 什么是 RPC？

RPC全称为（Remote Procedure Call），是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议，简单理解就是让开发者能够像调用本地服务一样调用远程服务。

## 📖 项目简介

本项目是《计算机网络》课程设计的成果物。这是一个基于 **TCP/IP 协议** 实现的轻量级远程过程调用（RPC）框架。
它能够让开发者像调用本地函数一样调用远程服务器上的服务，底层屏蔽了复杂的网络通信、序列化和动态代理细节。

---

## 🛠️ 技术栈

本项目采用以下技术栈实现：

### 核心框架与库

| 技术         | 版本           | 用途                                   |
|------------|--------------|--------------------------------------|
| **Java**   | 8 / 17       | 编程语言，使用 Java 8 作为编译目标，部分模块使用 Java 17 |
| **Maven**  | -            | 项目管理和构建工具，采用多模块架构                    |
| **Netty**  | 4.1.50.Final | 高性能 NIO 网络通信框架，实现 TCP 服务端和客户端        |
| **Lombok** | 1.18.24      | 简化 Java 代码，减少样板代码（如 getter/setter）   |
| **SLF4J**  | 1.7.30       | 日志门面框架，提供统一的日志接口                     |

### 核心技术特性

#### 1. **网络通信**

- ✅ **Netty NIO**：基于事件驱动的非阻塞 I/O 模型
- ✅ **TCP/IP 协议**：可靠的传输层协议
- ✅ **自定义应用层协议**：魔数 + 版本号 + 序列化算法 + 指令类型 + 数据长度 + 数据内容

#### 2. **序列化机制**

- ✅ **JSON 序列化**：轻量级、易读的数据交换格式
- 🔄 **Protobuf/Kryo**：高性能二进制序列化（可选扩展）

#### 3. **Java 核心特性**

- ✅ **JDK 动态代理**：实现客户端无感调用远程服务
- ✅ **Java 反射**：动态获取方法信息，实现方法调用
- ✅ **接口与实现分离**：通过接口定义服务契约

#### 4. **架构设计模式**

- ✅ **代理模式（Proxy Pattern）**：客户端动态代理
- ✅ **工厂模式（Factory Pattern）**：序列化器、代理对象创建
- ✅ **策略模式（Strategy Pattern）**：可插拔的序列化策略

### 技术选型说明

| 技术选型          | 原因                                         |
|---------------|--------------------------------------------|
| **Netty**     | 相比原生 NIO，Netty 提供了更高层次的抽象，简化了网络编程，同时保持了高性能 |
| **Maven 多模块** | 实现模块化开发，便于代码组织和依赖管理，符合单一职责原则               |
| **Lombok**    | 减少样板代码，提高开发效率，使代码更简洁易读                     |
| **SLF4J**     | 日志门面设计，便于后续切换不同的日志实现（如 Logback、Log4j2）     |
| **自定义协议**     | 相比 HTTP，自定义二进制协议具有更小的数据包体积和更低的延迟           |

### 开发环境要求

- **JDK**: 8 或以上（推荐 JDK 17）
- **Maven**: 3.6 或以上
- **IDE**: IntelliJ IDEA / Eclipse / VS Code（推荐 IntelliJ IDEA）

---

## 📂 项目结构说明

为了实现模块化开发，本项目采用 Maven 多模块架构：

* **`rpc-common`** (公共模块)
    * 存放客户端和服务端共用的实体对象（如 `RpcRequest`, `RpcResponse`）、枚举和工具类。
    * *注意：这是我们定义“通信协议”的地方。*
* **`rpc-core`** (核心框架)
    * RPC 的核心引擎。包含 Netty 网络通信、动态代理、序列化（JSON/Protobuf）、服务注册与发现机制。
* **`rpc-api`** (公共接口)
    * 定义服务接口（Interface）。客户端依赖它来调用，服务端依赖它来实现。
* **`rpc-test-server`** (测试服务端)
    * 服务提供方。启动后会将服务注册到注册中心，并监听端口等待请求。
* **`rpc-test-client`** (测试客户端)
    * 服务消费方。通过动态代理发起调用，验证框架是否可用。

### 详细文件结构

```
RPCFramework/
├── pom.xml                          # 父 POM 文件，管理所有子模块
├── README.md                        # 项目说明文档
├── .gitignore                       # Git 忽略文件配置
│
├── rpc-common/                      # 公共模块
│   ├── pom.xml                      # 模块 POM 配置
│   └── src/
│       ├── main/
│       │   ├── java/                # Java 源代码（实体类、枚举、工具类）
│       │   └── resources/           # 资源文件（配置文件等）
│       └── test/
│           └── java/                # 测试代码
│
├── rpc-core/                        # 核心框架模块
│   ├── pom.xml                      # 模块 POM 配置
│   └── src/
│       ├── main/
│       │   ├── java/                # 核心实现代码
│       │   │   ├── proxy/          # 动态代理相关
│       │   │   ├── transport/      # Netty 网络传输
│       │   │   ├── serializer/     # 序列化/反序列化
│       │   │   ├── registry/       # 服务注册与发现
│       │   │   └── ...             # 其他核心组件
│       │   └── resources/           # 资源文件
│       └── test/
│           └── java/                # 测试代码
│
├── rpc-api/                         # 公共接口模块
│   ├── pom.xml                      # 模块 POM 配置
│   └── src/
│       ├── main/
│       │   ├── java/                # 服务接口定义
│       │   └── resources/           # 资源文件
│       └── test/
│           └── java/                # 测试代码
│
├── rpc-test-server/                 # 测试服务端模块
│   ├── pom.xml                      # 模块 POM 配置
│   └── src/
│       ├── main/
│       │   ├── java/                # 服务端实现代码
│       │   │   ├── service/        # 服务实现类
│       │   │   └── Server.java     # 服务端启动类
│       │   └── resources/           # 配置文件（端口、注册中心地址等）
│       └── test/
│           └── java/                # 测试代码
│
└── rpc-test-client/                 # 测试客户端模块
    ├── pom.xml                      # 模块 POM 配置
    └── src/
        ├── main/
        │   ├── java/                # 客户端代码
        │   │   └── Client.java     # 客户端启动类
        │   └── resources/           # 配置文件
        └── test/
            └── java/                # 测试代码
```

### 模块依赖关系

```
rpc-test-client  ──┐
                   ├──> rpc-core ──> rpc-common
rpc-test-server  ──┘                ↑
                                    │
rpc-api ────────────────────────────┘
```

**说明**：

- `rpc-common` 是最底层模块，不依赖任何其他业务模块
- `rpc-core` 依赖 `rpc-common`，提供核心 RPC 功能
- `rpc-api` 定义服务接口，可被其他模块依赖
- `rpc-test-server` 和 `rpc-test-client` 都依赖 `rpc-core` 和 `rpc-api`，用于测试和演示

---

## 🎯 设计目的

1. **深入理解网络协议**：通过自定义应用层协议（魔数+版本号+长度+内容），深入实践 TCP 封包/拆包机制，解决粘包问题。
2. **掌握分布式原理**：从零实现 RPC 核心组件（代理、注册、网络），理解微服务架构中“服务解耦”的本质。
3. **提升架构能力**：通过 Netty NIO 实现高性能通信，利用 Java 反射与动态代理屏蔽底层细节。

## 💡 实际使用价值

1. **微服务基石**：RPC 是现代分布式系统（如淘宝、抖音后台）通信的基础，本项目可作为微服务架构的教学演示。
2. **跨语言/跨平台**：通过标准化的字节流协议，未来可扩展支持 Java 调用 Go/Python 服务。
3. **高性能通信**：相比传统的 HTTP/RESTful 调用，基于 TCP 长连接和二进制序列化的 RPC 拥有更低的时延和更小的数据包体积。

---

## 🎨 Figma 在本项目中的作用

虽然本项目是后端系统，但我们利用 **Figma** 进行系统架构的可视化设计与文档管理：

1. **架构可视化**：绘制 RPC 调用时序图（Sequence Diagram）和系统架构图，清晰展示 Request -> Proxy -> Netty -> Server 的全流程。
2. **协议结构图**：可视化展示自定义 TCP 数据包的二进制结构（Header + Body）。
3. **答辩展示**：用于生成高质量的课程设计报告插图和答辩演示素材。

---

## 🏗️ 架构设计评估

### ✅ 架构合理性分析

本项目的架构设计**非常合理**，符合 RPC 框架的最佳实践：

#### 1. **模块划分清晰，职责单一**

- ✅ **rpc-common**：公共实体和协议定义，无业务逻辑，依赖关系清晰
- ✅ **rpc-core**：核心框架实现，封装了所有 RPC 底层细节
- ✅ **rpc-api**：接口定义模块，实现接口与实现的分离
- ✅ **rpc-test-server/client**：测试模块，用于验证框架功能

#### 2. **依赖关系合理，避免循环依赖**

```
rpc-common (最底层，无依赖)
    ↑
rpc-core (依赖 common)
    ↑
rpc-api (独立模块，可被其他模块依赖)
    ↑
rpc-test-server/client (应用层，依赖 core 和 api)
```

#### 3. **符合设计原则**

- ✅ **单一职责原则**：每个模块职责明确
- ✅ **依赖倒置原则**：通过接口（rpc-api）实现解耦
- ✅ **开闭原则**：核心框架可扩展（序列化、注册中心等）

### 🎯 能否实现最终目的？

**完全可以实现！** 该架构设计能够满足课程设计的所有目标：

1. ✅ **理解网络协议**：通过 `rpc-core/transport` 模块实现自定义 TCP 协议，解决粘包问题
2. ✅ **掌握分布式原理**：通过 `rpc-core/proxy` 和 `rpc-core/registry` 实现服务注册与发现
3. ✅ **提升架构能力**：使用 Netty NIO 和动态代理，体现高性能和易用性

### ⚠️ 需要注意的潜在问题

1. **服务注册中心**：如果使用独立的注册中心（如 Zookeeper、Nacos），需要额外模块或配置
2. **负载均衡**：多服务实例时的负载均衡策略需要在 `rpc-core` 中实现
3. **容错机制**：超时、重试、熔断等机制需要在核心框架中考虑

---

## ⚙️ 核心原理与架构设计

本框架通过以下五个核心模块，解决了分布式系统通信中的关键问题：

### 1. 代理模式 (Proxy Pattern) - 实现“无感调用”

* **原理**：客户端并没有可以直接调用的服务实现类。为了让用户感觉像在调用本地方法，我们使用了 **JDK 动态代理**。
* **流程**：
    1. 当用户调用接口（如 `userService.getUser()`）时，代理对象拦截该调用。
    2. 代理对象获取被调用的**类名**、**方法名**、**参数类型**和**参数值**。
    3. 将这些信息封装成一个 `RpcRequest` 对象，准备发送给服务端。

### 2. 序列化机制 (Serialization) - 对象的“打包”

* **问题**：Java 对象存在于内存中，无法直接在网络上传输。
* **解决方案**：
    * **序列化 (Serialize)**：客户端将 `RpcRequest` 对象转换为二进制字节流（byte[]）。
    * **反序列化 (Deserialize)**：服务端接收到字节流后，将其还原为 `RpcRequest` 对象。
* **选型**：本项目支持 **JSON** 或 **Kryo/Protobuf** 序列化，相比 Java 原生序列化，体积更小，传输效率更高。

### 3. 网络通信与 I/O 模型 (Netty/NIO)

* **底层通信**：摒弃传统的阻塞式 I/O (BIO)，采用 **Netty** 框架实现基于 **NIO (Non-blocking I/O)** 的异步通信。
* **优势**：通过 Netty 的 Reactor 线程模型，服务端可以用少量的线程处理大量客户端并发连接，避免了“一个连接一个线程”的资源浪费。

### 4. 通信协议设计 (Protocol)

为了保证数据传输的完整性，我们要设计如下协议头（Header）：

```text
+---------------------------------------------------------------+
| 魔数 (4byte) | 版本号 (1byte) | 序列化算法 (1byte) | 指令类型 (1byte) |
+---------------------------------------------------------------+
|                      数据长度 (4byte)                          |
+---------------------------------------------------------------+
|                   数据内容 (Body / Payload)                    |
+---------------------------------------------------------------+
```

---

## 📝 开发建议

### 建议的实现顺序

1. **第一阶段：基础通信**
    - 实现 `rpc-common` 中的 `RpcRequest`、`RpcResponse`
    - 实现 `rpc-core/transport` 中的 Netty 服务端和客户端
    - 实现自定义协议编解码器

2. **第二阶段：序列化**
    - 实现 `rpc-core/serializer` 中的序列化接口
    - 实现 JSON 序列化器
    - （可选）实现 Protobuf 序列化器

3. **第三阶段：动态代理**
    - 实现 `rpc-core/proxy` 中的代理工厂
    - 实现客户端代理调用逻辑

4. **第四阶段：服务注册与发现**
    - 实现 `rpc-core/registry` 中的注册中心接口
    - （可选）集成 Zookeeper 或实现内存注册中心

5. **第五阶段：测试验证**
    - 在 `rpc-api` 中定义测试接口
    - 在 `rpc-test-server` 中实现服务
    - 在 `rpc-test-client` 中编写测试代码
